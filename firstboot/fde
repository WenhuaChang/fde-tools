#!/bin/bash
#
#   Copyright (C) 2022 SUSE LLC
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#   Written by Olaf Kirch <okir@suse.com>

. /etc/sysconfig/fde-tools

. /usr/share/fde/util
. /usr/share/fde/luks
. /usr/share/fde/tpm
. /usr/share/fde/uefi
. /usr/share/fde/grub2

# dialog functions that use the firstboot plumbing
. /usr/share/fde/ui/dialog

##################################################################
# Values and locations used by KIWI
##################################################################
KIWI_ROOT_KEYFILE=/root/.root.keyfile
KIWI_ROOT_PASSPHRASE="1234"

function fde_protect_tpm {

    local luks_dev=$1
    local luks_keyfile=$2

    luks_set_random_key "${luks_dev}" "${luks_keyfile}"

    efi_grub_dir=/boot/efi/EFI/BOOT

    # First update grub.cfg...
    grub_update_early_config "$efi_grub_dir" sealed.key \
				"$FDE_SEAL_PCR_BANK" "$FDE_SEAL_PCR_LIST"

    # ... then seal the key against a PCR9 value that covers grub.cfg
    tpm_seal_secret "${luks_keyfile}" "${efi_grub_dir}" "$efi_grub_dir/sealed.key"

    return $?
}

function fde_setup_encrypted {

    root_dev=$1
    luks_keyfile="$2"
    luks_recovery_pass="$3"

    with_pass=false
    with_tpm=false
    with_ccid=false

    for method in $FDE_PROTECTION; do
    	case $method in
	pass) with_pass=true;;
	tpm)  with_tpm=true;;
	ccid) with_ccid=true;;
	esac
    done

    if ! [[ "$root_dev" =~ /dev/mapper/.* ]]; then
	display_errorbox "root device $root_dev does not look like a dm device"
        return 1
    fi

    luks_name=$(expr "$root_dev" : ".*/\(.*\)")
    luks_dev=$(luks_get_underlying_device "$luks_name")
    if [ -z "$luks_dev" ]; then
        display_errorbox "Unable to determine underlying LUKS device for $root_dev"
	return 1
    fi

    if $with_tpm && ! tpm_test $FDE_KEY_SIZE_BYTES; then
	display_errorbox "TPM key sealing and unsealing does not seem to work"
	return 1
    fi

    # Change the built-in recovery password to the one provided by the user
    if $with_pass && ! luks_change_password "${luks_dev}" "${luks_recovery_pass}"; then
	display_errorbox "Failed to change recovery password."
	with_pass=false
    fi

    # "cryptsetup reencrypt" requires to specify the key slot number (--key-slot) if
    # there are multiple key slots and only the specified key slot will survive after
    # reencryption. There are two key slots already in the partition: one for the
    # password and the other one for the random key. To avoid the additional key slot
    # parameter, drop the old random key if the user chooses a recovery password.
    # Otherwise, drop the password key slot.
    if $with_pass; then
        # Drop the random key slot and use the password for reencryption
        if ! luks_drop_key "${luks_dev}" "${luks_keyfile}"; then
            display_errorbox "Failed to remove initial random key"
            return 1
        fi

        # Reencrypt with the new password
        pass_keyfile=$(luks_write_password pass "${result_password}")
        luks_reencrypt "${luks_dev}" "${pass_keyfile}"

        # Generate a random key again
        luks_add_random_key "${luks_dev}" "${pass_keyfile}" "${luks_keyfile}"

        # Remove the password file
        rm -f ${pass_keyfile}
    else
        # Drop the password key slot and use the random key for reencryption
        if ! luks_drop_pass "${luks_dev}" "${luks_recovery_pass}"; then
            display_errorbox "Failed to remove initial password"
            return 1
        fi

        # Reencrypt with the old random key
        luks_reencrypt "${luks_dev}" "${luks_keyfile}"
    fi

    if $with_tpm && ! fde_protect_tpm "${luks_dev}" "${luks_keyfile}"; then
	display_errorbox "Failed to protect encrypted volume with TPM"
	with_tpm=false
    fi

    if $with_pass || $with_tpm || $with_ccid; then
    	: all is well
    else
	return 1
    fi

    # Normally, kiwi wants to keep the "key" that unlocks LUKS in .root.keyfile.
    # However, since we're protecting that key with the TPM now, there's no
    # need to keep a secret bit of data around as clear-text, copying it into
    # initrd and potentially leaking it.
    rm -f "${luks_keyfile}"
}

function fde_setup_unencrypted {

    root_dev=$1
    luks_keyfile="$2"
    luks_recovery_pass="$3"

    if ! [[ "$root_dev" =~ /dev/mapper/.* ]]; then
	display_errorbox "root device $root_dev does not look like a dm device"
        return 1
    fi

    luks_name=$(expr "$root_dev" : ".*/\(.*\)")
    luks_dev=$(luks_get_underlying_device "$luks_name")
    if [ -z "$luks_dev" ]; then
        display_errorbox "Unable to determine underlying LUKS device for $root_dev"
	return 1
    fi

    luks_decrypt "${luks_dev}" "${luks_keyfile}"

    rm -f "${luks_keyfile}"
    rm -f /etc/crypttab

    display_infobox "Re-creating initial ramdisk"
    if ! mkinitrd >&2; then
	display_errorbox "Failed to rebuild initrd"
	return 1
    fi

    return 0
}


function __fde_valid_protections {

    for tag in $*; do
        case $tag in
        pass|tpm) : ;;
        *)
	    display_errorbox "FDE key protection scheme $tag not yet implemented"
	    return 1;;
        esac
    done

    return 0
}

##################################################################
# Check what protection method the system supports and let the
# user choose.
# returns false if the user declined device encryption
# The ccid thing is there just as a teaser for now :-)
##################################################################
function fde_choose_protection {

    declare -g FDE_PROTECTION
    declare -a options

    FDE_PROTECTION=""

    message="ALP can be installed with an encrypted root and boot partition. Please choose the desired protection method(s) or press Cancel to install without encryption"
    options+=(pass 'Pass phrase' on)

    if ! tpm_present_and_working; then
	display_infobox "This system does not seem to have a working TPM device."
    else
    	options+=(tpm 'Stored inside the TPM chip' on)
    fi

    options+=(ccid 'Stored inside a CCID capable token' off)

    while true; do
        d --title "Full Disk Encryption" --checklist \
			"$message" 12 74 4 \
			"${options[@]}"

	if [ $? -ne 0 ]; then
	    FDE_PROTECTION=""
	    return 1
	fi

	FDE_PROTECTION="$result"
	fde_trace "user selected protections: <$FDE_PROTECTION>"

	if [ -z "$FDE_PROTECTION" ]; then
	    return 1
	fi

	if __fde_valid_protections $FDE_PROTECTION; then
	    break
	fi
    done

    return 0
}

function fde_firstboot {

    if fde_choose_protection; then
	if fde_setup_encrypted "$@"; then
	    return 0
	fi

	display_errorbox "Failed to set up for full disk encryption. Trying to recover"
    fi

    fde_setup_unencrypted "$@"
}

function fde_systemd_firstboot {

    if ! uefi_secure_boot_enabled; then
	display_infobox "This system does not seem to use Secure Boot. Full disk encryption not available"
	return 1
    fi

    display_infobox "Full Disk Encryption with TPM2 support"

    set -x

    if [ ! -f "$KIWI_ROOT_KEYFILE" ]; then
	display_errorbox "Missing $KIWI_ROOT_KEYFILE. FDE setup will most likely fail."
    fi

    # FIXME: rather than hard-coding the recovery password here,
    # have kiwi write it to /.root.something and read it from there
    fde_firstboot $(luks_device_for_path "/") "$KIWI_ROOT_KEYFILE" "$KIWI_ROOT_PASSPHRASE" 2>/var/log/fde-firstboot.log

    set +x

    fde_clean_tempdir
}

function fde_post {

    :
}

function fde_cleanup {

    :
}
