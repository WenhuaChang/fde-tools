#!/bin/bash
#
#   Copyright (C) 2022 SUSE LLC
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#   Written by Olaf Kirch <okir@suse.com>

. /etc/sysconfig/fde

. /usr/share/fde/util
. /usr/share/fde/luks
. /usr/share/fde/tpm
. /usr/share/fde/grub2

##################################################################
# Values and locations used by KIWI
##################################################################
KIWI_ROOT_KEYFILE=/root/.root.keyfile
KIWI_ROOT_PASSPHRASE="1234"

function __get_root_dev {

    df / | grep /dev/ | cut -f1 -d' '
}

function request_password {

    declare -g result_password

    prompt="$1"
    defpass=$2

    result_password=""

    if [ -n "$defpass" ]; then
	prompt+=" Press Cancel to retain default ($defpass)"
	nocancel=
    else
	nocancel="--no-cancel"
    fi

    attempt=0

    while [ $attempt -lt 3 ]; do
	let attempt+=1

	fde_infobox "About to request password (#$attempt)"
	if ! d $nocancel --insecure --passwordbox "${prompt}" 8 50; then
	    # cancelling the dialog means "I don't want to set this password"
	    echo "${defpass}"
	    return 0
	fi

	password1="$result"

	if d --no-cancel --insecure --passwordbox "Please retype password" 8 50; then
	    password2="$result"
	    if [ "${password1}" = "${password2}" ];  then
		result_password="${password1}"
		return 0
	    fi
	fi
    done
    return 1
}

function display_gauge {

    d --gauge "$*" 7 40
}

function mount_system_fs {

    declare -g MOUNTED_DIRS
    declare -g SYSTEM_MP

    where="$1"; shift
    destdir="${SYSTEM_MP}/$where"
    if ! mount "$@" "$destdir"; then
	echo "Failed to mount system $where" >&2
	return 1
    fi

    MOUNTED_DIRS="$destdir $MOUNTED_DIRS"
    return 0
}

function mount_system_begin {

    declare -g MOUNTED_DIRS
    declare -g SYSTEM_MP

    mountpoint="$1"

    SYSTEM_MP="$mountpoint"
    mkdir "$SYSTEM_MP"

    MOUNTED_DIRS=""
}

function unmount_system {

    declare -g MOUNTED_DIRS
    declare -g SYSTEM_MP

    for dir in $MOUNTED_DIRS; do
	umount $dir
    done

    rmdir $SYSTEM_MP

    unset MOUNTED_DIRS SYSTEM_MP
}

function fde_protect_tpm {

    local luks_dev=$1
    local luks_keyfile=$2

    luks_set_random_key "${luks_dev}" "${luks_keyfile}"

    efi_grub_dir=/boot/efi/EFI/BOOT

    # First update grub.cfg...
    grub_update_early_config "$efi_grub_dir" sealed.key

    # ... then seal the key against a PCR9 value that covers grub.cfg
    tpm_seal_secret "${luks_keyfile}" "${efi_grub_dir}" "$efi_grub_dir/sealed.key"

    return $?
}

function fde_setup_encrypted {

    root_dev=$1
    luks_keyfile="$2"
    luks_recovery_pass="$3"

    with_pass=false
    with_tpm=false
    with_ccid=false

    for method in $FDE_PROTECTION; do
    	case $method in
	pass) with_pass=true;;
	tpm)  with_tpm=true;;
	ccid) with_ccid=true;;
	esac
    done

    if ! [[ "$root_dev" =~ /dev/mapper/.* ]]; then
	fde_error "root device $root_dev does not look like a dm device"
        return 1
    fi

    luks_name=$(expr "$root_dev" : ".*/\(.*\)")
    luks_dev=$(luks_get_underlying_device "$luks_name")
    if [ -z "$luks_dev" ]; then
        fde_error "Unable to determine underlying LUKS device for $root_dev"
	return 1
    fi

    if $with_tpm && ! tpm_test $FDE_KEY_SIZE_BYTES; then
	fde_error "TPM key sealing and unsealing does not seem to work"
	return 1
    fi

    # Change the built-in recovery password to the one provided by the user
    if $with_pass && ! luks_change_password "${luks_dev}" "${luks_recovery_pass}"; then
	fde_error "Failed to change recovery password."
	with_pass=false
    fi

    # "cryptsetup reencrypt" requires to specify the key slot number (--key-slot) if
    # there are multiple key slots and only the specified key slot will survive after
    # reencryption. There are two key slots already in the partition: one for the
    # password and the other one for the random key. To avoid the additional key slot
    # parameter, drop the old random key if the user chooses a recovery password.
    # Otherwise, drop the password key slot.
    if $with_pass; then
        # Drop the random key slot and use the password for reencryption
        if ! luks_drop_key "${luks_dev}" "${luks_keyfile}"; then
            fde_error "Failed to remove initial random key"
            return 1
        fi

        # Reencrypt with the new password
        pass_keyfile=$(luks_write_password pass "${result_password}")
        luks_reencrypt "${luks_dev}" "${pass_keyfile}"

        # Generate a random key again
        luks_add_random_key "${luks_dev}" "${pass_keyfile}" "${luks_keyfile}"

        # Remove the password file
        rm -f ${pass_keyfile}
    else
        # Drop the password key slot and use the random key for reencryption
        if ! luks_drop_pass "${luks_dev}" "${luks_recovery_pass}"; then
            fde_error "Failed to remove initial password"
            return 1
        fi

        # Reencrypt with the old random key
        luks_reencrypt "${luks_dev}" "${luks_keyfile}"
    fi

    if $with_tpm && ! fde_protect_tpm "${luks_dev}" "${luks_keyfile}"; then
	fde_error "Failed to protect encrypted volume with TPM"
	with_tpm=false
    fi

    if $with_pass || $with_tpm || $with_ccid; then
    	: all is well
    else
	return 1
    fi

    # Normally, kiwi wants to keep the "key" that unlocks LUKS in .root.keyfile.
    # However, since we're protecting that key with the TPM now, there's no
    # need to keep a secret bit of data around as clear-text, copying it into
    # initrd and potentially leaking it.
    rm -f "${luks_keyfile}"
}

function fde_setup_unencrypted {

    root_dev=$1
    luks_keyfile="$2"
    luks_recovery_pass="$3"

    if ! [[ "$root_dev" =~ /dev/mapper/.* ]]; then
	fde_error "root device $root_dev does not look like a dm device"
        return 1
    fi

    luks_name=$(expr "$root_dev" : ".*/\(.*\)")
    luks_dev=$(luks_get_underlying_device "$luks_name")
    if [ -z "$luks_dev" ]; then
        fde_error "Unable to determine underlying LUKS device for $root_dev"
	return 1
    fi

    luks_decrypt "${luks_dev}" "${luks_keyfile}"

    rm -f "${luks_keyfile}"
    rm -f /etc/crypttab

    fde_infobox "Re-creating initial ramdisk"
    if ! mkinitrd >&2; then
    	fde_error "Failed to rebuild initrd"
	return 1
    fi

    return 0
}


function get_efivar_binary_byte {

    name="$1"
    path="/sys/firmware/efi/vars/$name/data"
    if [ ! -f "$path" ]; then
	echo "n/a"
    else
	cat "$path" | tr '\0\1' '01'
    fi
}

function fde_platform_is_tpm_capable {

    if ! tpm2_selftest -V -f; then
	fde_trace "This system does not have a TPM2 chip. Full disk encryption not available"
	return 1
    fi

    if ! [ -d /sys/firmware/efi ]; then
	fde_trace "This system does not seem to use UEFI. Full disk encryption not available"
	return 1
    fi

    secure_boot=$(get_efivar_binary_byte SecureBoot-8be4df61-93ca-11d2-aa0d-00e098032b8c)
    setup_mode=$(get_efivar_binary_byte SetupMode-8be4df61-93ca-11d2-aa0d-00e098032b8c)
    if [ "$secure_boot" != 1 -a "$setup_mode" != 0 ]; then
	fde_trace "Secure Boot not enabled (secure_boot=$secure_boot; setup_mode=$setup_mode)"
	fde_trace "This system does not seem to use Secure Boot. Full disk encryption not available"
	return 1
    fi

    return 0
}

function __fde_valid_protections {

    for tag in $*; do
        case $tag in
        pass|tpm) : ;;
        *)
	    fde_error "FDE key protection scheme $tag not yet implemented"
	    return 1;;
        esac
    done

    return 0
}

##################################################################
# Check what protection method the system supports and let the
# user choose.
# returns false if the user declined device encryption
# The ccid thing is there just as a teaser for now :-)
##################################################################
function fde_choose_protection {

    declare -g FDE_PROTECTION
    declare -a options

    FDE_PROTECTION=""

    message="ALP can be installed with an encrypted root and boot partition. Please choose the desired protection method(s) or press Cancel to install without encryption"
    options+=(pass 'Pass phrase' on)

    if fde_platform_is_tpm_capable; then
    	options+=(tpm 'Stored inside the TPM chip' on)
    fi

    options+=(ccid 'Stored inside a CCID capable token' off)

    while true; do
        d --title "Full Disk Encryption" --checklist \
			"$message" 12 74 4 \
			"${options[@]}"

	if [ $? -ne 0 ]; then
	    FDE_PROTECTION=""
	    return 1
	fi

	FDE_PROTECTION="$result"
	fde_trace "user selected protections: <$FDE_PROTECTION>"

	if [ -z "$FDE_PROTECTION" ]; then
	    return 1
	fi

	if __fde_valid_protections $FDE_PROTECTION; then
	    break
	fi
    done

    return 0
}

function fde_firstboot {

    if fde_choose_protection; then
	if fde_setup_encrypted "$@"; then
	    return 0
	fi

	fde_error "Failed to set up for full disk encryption. Trying to recover"
    fi

    fde_setup_unencrypted "$@"
}

function fde_systemd_firstboot {

    fde_infobox "Full Disk Encryption with TPM2 support"

    set -x

    if [ ! -f "$KIWI_ROOT_KEYFILE" ]; then
    	fde_error "Missing $KIWI_ROOT_KEYFILE. FDE setup will most likely fail."
    fi

    # FIXME: rather than hard-coding the recovery password here,
    # have kiwi write it to /.root.something and read it from there
    fde_firstboot $(__get_root_dev) "$KIWI_ROOT_KEYFILE" "$KIWI_ROOT_PASSPHRASE" 2>/var/log/fde-firstboot.log

    set +x

    fde_clean_tempdir
}

function fde_post {

    :
}

function fde_cleanup {

    :
}
